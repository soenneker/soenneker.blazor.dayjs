@namespace Soenneker.Blazor.Dayjs
@using System
@using System.Globalization
@using System.Text
@using System.Threading
@using System.Threading.Tasks
@using Soenneker.Blazor.Dayjs.Utils
@using Soenneker.Quark

@inherits CoreCancellableComponent

@if (_value is not null)
{
    @(_value)
}

@code {
    [Parameter] public DateTimeOffset Value { get; set; }
    [Parameter] public string Format { get; set; } = "mm:ss";
    [Parameter] public string? UpdateInterval { get; set; } = "1s";
    [Parameter] public string? Timezone { get; set; }
    [Parameter] public bool ClampToZero { get; set; } = true;
    [Parameter] public bool AutomaticUpdate { get; set; } = true;

    private string? _value;
    private DayJsSubscriptionKey _subscriptionKey;
    private bool _hasSubscriptionKey;

    protected override async Task OnParametersSetAsync()
    {
        var key = new DayJsSubscriptionKey(Value.ToUnixTimeMilliseconds(), Format, UpdateInterval, Timezone, false, ClampToZero, AutomaticUpdate);

        if (_hasSubscriptionKey && _subscriptionKey.Equals(key))
            return;

        _subscriptionKey = key;
        _hasSubscriptionKey = true;
        await Resubscribe();
    }

    private async Task Resubscribe()
    {
        await ResetCancellation();

        if (!AutomaticUpdate)
        {
            _value = FormatRemaining();
            _ = InvokeAsync(StateHasChanged);
            return;
        }

        var interval = DayJsIntervalParser.ParseOrDefault(UpdateInterval, TimeSpan.FromSeconds(1));
        _value = FormatRemaining();
        _ = InvokeAsync(StateHasChanged);
        _ = RunLoop(interval, CancellationToken);
    }

    private async Task RunLoop(TimeSpan interval, CancellationToken token)
    {
        try
        {
            using var timer = new PeriodicTimer(interval);

            while (await timer.WaitForNextTickAsync(token))
            {
                _value = FormatRemaining();
                _ = InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
        }
    }

    private string FormatRemaining()
    {
        var now = GetNow();
        var remaining = Value - now;

        if (ClampToZero && remaining < TimeSpan.Zero)
            remaining = TimeSpan.Zero;

        var format = EscapeTimeSpanFormat(Format);
        return remaining.ToString(format, CultureInfo.InvariantCulture);
    }

    private DateTimeOffset GetNow()
    {
        if (string.IsNullOrWhiteSpace(Timezone))
            return DateTimeOffset.Now;

        if (TryResolveTimeZone(Timezone, out TimeZoneInfo? zone))
            return TimeZoneInfo.ConvertTime(DateTimeOffset.UtcNow, zone);

        return DateTimeOffset.Now;
    }

    private static bool TryResolveTimeZone(string timezone, out TimeZoneInfo? zone)
    {
        try
        {
            zone = TimeZoneInfo.FindSystemTimeZoneById(timezone);
            return true;
        }
        catch (TimeZoneNotFoundException)
        {
            zone = null;
            return false;
        }
        catch (InvalidTimeZoneException)
        {
            zone = null;
            return false;
        }
    }

    private static string EscapeTimeSpanFormat(string format)
    {
        if (string.IsNullOrWhiteSpace(format))
            return "c";

        var builder = new StringBuilder(format.Length + 2);
        var escaping = false;

        foreach (char ch in format)
        {
            if (escaping)
            {
                builder.Append(ch);
                escaping = false;
                continue;
            }

            if (ch == '\\')
            {
                builder.Append(ch);
                escaping = true;
                continue;
            }

            if (ch == ':')
            {
                builder.Append('\\');
            }

            builder.Append(ch);
        }

        return builder.ToString();
    }

    public override async ValueTask DisposeAsync()
    {
        await base.DisposeAsync();
    }
}
