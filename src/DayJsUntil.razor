@namespace Soenneker.Blazor.Dayjs
@using System
@using Soenneker.Blazor.Dayjs.Abstract
@using Soenneker.Blazor.Dayjs.Dtos
@using Soenneker.Blazor.Dayjs.Utils
@inject IDayJsInterop DayJsInterop

@inherits Soenneker.Quark.CoreCancellableComponent

@if (_value is not null)
{
    @(_value)
}

@code {
    [Parameter] public DateTimeOffset Value { get; set; }
    [Parameter] public string Format { get; set; } = "mm:ss";
    [Parameter] public string? UpdateInterval { get; set; } = "1s";
    [Parameter] public string? Timezone { get; set; }
    [Parameter] public bool ClampToZero { get; set; } = true;
    [Parameter] public bool AutomaticUpdate { get; set; } = true;

    private string? _value;
    private DayJsSubscription? _subscription;
    private DayJsSubscriptionKey _subscriptionKey;
    private bool _hasSubscriptionKey;

    protected override async Task OnParametersSetAsync()
    {
        var key = new DayJsSubscriptionKey(Value.ToUnixTimeMilliseconds(), Format, UpdateInterval, Timezone, false, ClampToZero, AutomaticUpdate);

        if (_hasSubscriptionKey && _subscription is not null && _subscriptionKey.Equals(key))
            return;

        _subscriptionKey = key;
        _hasSubscriptionKey = true;
        await Resubscribe();
    }

    private async Task Resubscribe()
    {
        var token = CancellationToken;

        if (_subscription is not null)
            await _subscription.DisposeAsync();

        if (!AutomaticUpdate)
        {
            _subscription = null;
            _value = await DayJsInterop.Until(Value, Format, Timezone, ClampToZero, token);
            _ = InvokeAsync(StateHasChanged);
            return;
        }

        var interval = DayJsIntervalParser.ParseOrDefault(UpdateInterval, TimeSpan.FromSeconds(1));

        _subscription = await DayJsInterop.SubscribeUntil(
            Value,
            Format,
            interval,
            value =>
            {
                _value = value;
                _ = InvokeAsync(StateHasChanged);
            },
            Timezone,
            ClampToZero,
            token);
    }

    public override async ValueTask DisposeAsync()
    {
        if (_subscription is not null)
            await _subscription.DisposeAsync();

        await base.DisposeAsync();
    }

}
